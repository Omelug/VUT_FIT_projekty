<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-2">
<META HTTP-EQUIV="Content-language" CONTENT="cs">
<TITLE>IJC: DU1 </TITLE>
</HEAD>
<BODY>

<H1>IJC: DU1</H1>

<HR>
<XMP>

Jazyk C                     DU1                        20.2.2024
----------------------------------------------------------------


                      Domácí úkol è.1


Termín odevzdání:  25.3.2024
 Hodnocení celkem max. 15 bodù
 Ètìte pokyny na konci tohoto textu

Pøíklady: (budou opravovány v prostøedí Linux/GCC,
           LC_ALL=cs_CZ.utf8
           pøeklad: gcc -g -std=c11 -pedantic -Wall -Wextra 
           C11 je potøeba jen pro static_assert)

A) V rozhraní "bitset.h" definujte datovou strukturu typu pole bitù:

   Typ:
     typedef <DOPLNIT> bitset_t;
       Typ bitového pole (pro pøedávání parametru do funkce odkazem).

     typedef unsigned long bitset_index_t;
        Typ indexu bitového pole.

   Makra:
     bitset_create(jmeno_pole,velikost)
       definuje a _nuluje_ promìnnou jmeno_pole
       (POZOR: opravdu musí _INICIALIZOVAT_ pole bez ohledu na
       to, zda je pole statické nebo automatické/lokální!
       Vyzkou¹ejte obì varianty, v programu pou¾ijte _lokální_ pole.)
       Pou¾ijte  static_assert  pro kontrolu velikosti pole.
       Pø: static bitset_create(p,100); // p = pole 100 bitù, nulováno
           bitset_create(q,100000L);    // q = pole 100000 bitù, nulováno
           bitset_create(q,-100);       // chyba pøi pøekladu

     bitset_alloc(jmeno_pole,velikost)
       definuje promìnnou jmeno_pole tak, aby byla kompatibilní s polem
       vytvoøeným pomocí bitset_create, ale pole bude alokováno dynamicky.
       Pø: bitset_alloc(q,100000L); // q = pole 100000 bitù, nulováno
       Pou¾ijte  assert  pro kontrolu velikosti pole.
       Pokud alokace sel¾e, ukonèete program s chybovým hlá¹ením:
       "bitset_alloc: Chyba alokace pamìti"

     bitset_free(jmeno_pole)
       uvolní pamì» dynamicky (pomocí bitset_alloc) alokovaného pole

     bitset_size(jmeno_pole)
       vrátí deklarovanou velikost pole v bitech (ulo¾enou v poli)

     bitset_fill(jmeno_pole, bool_výraz)
       vynuluje(false) nebo nastaví na 1(true) celý obsah pole

     bitset_setbit(jmeno_pole,index,bool_výraz)
       nastaví zadaný bit v poli na hodnotu zadanou výrazem
       (nulový výraz == false == bit 0, jinak bit 1)
       Pø: bitset_setbit(p,20,1);

     bitset_getbit(jmeno_pole,index)
       získá hodnotu zadaného bitu, vrací hodnotu 0 nebo 1
       Pø: if(bitset_getbit(p,i)==1) printf("1");
           if(!bitset_getbit(p,i))   printf("0");

   Kontrolujte meze polí. V pøípadì chyby volejte funkci

     error_exit("bitset_getbit: Index %lu mimo rozsah 0..%lu",
               (unsigned long)index, (unsigned long)mez).

   (Mù¾ete pou¾ít napøíklad modul error.c/error.h z pøíkladu b)

   Programy musí fungovat na 32 (gcc -m32) i 64bitové platformì.

   Podmínìným pøekladem zajistìte, aby se pøi definovaném symbolu
   USE_INLINE místo tìchto maker definovaly inline funkce stejného jména
   v¹ude kde je to mo¾né (bez zmìn v následujícím testovacím pøíkladu!).
   Pozor: USE_INLINE nesmí být definováno ve zdrojovém textu --
          pøekládá se s argumentem -D (gcc -DUSE_INLINE ...).

   Program musí fungovat s inline funkcemi i pro vypnuté optimalizace -O0
   (ovìøte si to - vy¾aduje externí definice inline funkcí).

   Pro va¹i implementaci pou¾ijte pole typu  unsigned long [].
   V tomto poli na indexu 0 bude velikost bitového pole v bitech.
   Implementace musí efektivnì vyu¾ívat pamì» (vyu¾ít ka¾dý
   bit pole a¾ na posledních maximálnì CHAR_BIT*sizeof(unsigned long)-1 bitù).

   Jako testovací pøíklad implementujte funkci, která pou¾ije algoritmus známý
   jako Eratostenovo síto (void Eratosthenes(bitset_t pole);) a pou¾ijte ji
   pro výpoèet posledních 10 prvoèísel ze v¹ech prvoèísel od 2 do
   N=666000000 (666 milionù). Doporuèuji program nejdøíve odladit pro N=100.
   Hodnotu N si funkce zjistí podle velikosti bitového pole.
   Funkci Eratosthenes napi¹te do samostatného modulu "eratosthenes.c".

   Ka¾dé prvoèíslo tisknìte na zvlá¹tní øádek v poøadí
   vzestupném.  Netisknìte  nic  jiného  ne¾  prvoèísla (bude se
   automaticky  kontrolovat!).  Pro kontrolu správnosti prvoèísel
   mù¾ete pou¾ít program "factor" (./primes|factor).

   Naprogramujte (s vyu¾itím funkce clock()) mìøení doby bìhu programu v
   sekundách a výsledek vypi¹te na stderr následujícím pøíkazem:
     fprintf(stderr, "Time=%.3g\n", (double)(clock()-start)/CLOCKS_PER_SEC);
   (Porovnejte si va¹e mìøení s výsledkem pøíkazu "time ./primes".)

   Pro lokální pole budete potøebovat zvìt¹it limit velikosti zásobníku.
   Na UNIX systémech mù¾ete pou¾ít pøíkaz "ulimit -a" pro zji¹tìní velikosti
   limitu a potom "ulimit -s zadana_velikost_v_KiB" pøed spu¹tìním programu.
   (Toto názornì demonstruje nevhodnost pou¾ívání velkých lokálních polí.)

   Zdrojový text programu se musí jmenovat "primes.c" !
   Napi¹te Makefile tak, aby pøíkaz "make" vytvoøil v¹echny varianty:
     primes      pou¾ívá makra
     primes-i    pou¾ívá inline funkce
   a aby pøíkaz "make run" v¹echny varianty vytvoøil a spustil (i s ulimit -s).

   (Pøi nesplnìní vý¹e uvedených podmínek: a¾ 0 bodù.)

(8b)

Poznámky:  Eratosthenovo síto (pøibli¾ná specifikace):
   1) Nastavíme bitové pole  p  o rozmìru N na samé 1.
      Nastavíme p[0]=0; p[1]=0; // 0 a 1 nejsou prvoèísla
      index i nastavit na 2
   2) Vybereme nejmen¹í index i, takový, ¾e p[i]==1.
      Potom je i prvoèíslo
   3) Pro v¹echny násobky i nastavíme bit p[n*i] na 0
      ('vy¹krtneme' v¹echny násobky i - nejsou to prvoèísla)
   4) i++; dokud nejsme za sqrt(N), opakujeme bod 2 a¾ 4
      (POZOR: sestavit s matematickou knihovnou parametrem -lm)
   5) Výsledek: v poli p jsou na prvoèíselných indexech hodnoty 1,
      (=nebyly vy¹krtnuty jako násobek nìjakého men¹ího prvoèísla)

   https://en.wikipedia.org/wiki/Prime_number

   Efektivita výpoètu: cca 4.25s na Ryzen 5 4600G (gcc -O2)
   Porovnejte efektivitu obou variant (makra vs. inline funkce).
   Zamyslete se, jak by se ovìøila efektivita pro (neinline) funkce.

</XMP>
<HR>
<XMP>

B) Napi¹te modul "error.c" s rozhraním v "error.h", který definuje
   funkci void warning(const char *fmt, ...) a
   funkci void error_exit(const char *fmt, ...).
   Tyto funkce mají stejné parametry jako printf(); tisknou
   text "Warning: " nebo "Error: " a potom chybové hlá¹ení podle
   formátu fmt. V¹e se tiskne do stderr (standardní funkcí vfprintf)
   a potom pouze error_exit ukonèí program voláním funkce exit(1).
   Pou¾ijte definice ze <stdarg.h>.

   Napi¹te program "no-comment.c", který vynechá poznámky ze zdrojového kódu
   jazyka C, který naètete ze souboru zadaného jako jediný argument programu.
   Pokud argument programu chybí, ète stdin. Výstup bude v¾dy na stdout
   (POZOR: pokud bude omylem pøesmìrován do vstupního souboru, chování je
   nedefinováno - tento problém lze zjistit pomocí POSIX funkce fstat).

   Musíte pou¾ít stavový automat a øe¹it i znaky v øetìzcových a znakových
   literálech (napø. øetìzec "/***/" není poznámka = nenahrazovat mezerou,
   "text\"text", '\\' a '\''  musí fungovat, atd.).

   Program pou¾ije error_exit v pøípadì chyby ètení souboru (soubor
   neexistuje, neukonèená poznámka nebo øetìzec atd.), jinak
   pøedpokládejte syntakticky korektní vstupní soubor (pùjde pøelo¾it)
   a zdrojové kódování ve formátu UTF-8 (nemìl by být ¾ádný problém
   se zpracováním po 8bit znacích, proto¾e znaky /*'"\ jsou v ASCII).

   Pou¾ijte program "make" pro pøeklad/sestavení programu.
   Testovací pøíkaz:  ./no-comment no-comment.c
                      ./no-comment no-comment.c >no-comment-result

(7b)

   Zaøiïte, aby pøíkaz "make" bez parametrù vytvoøil v¹echny spustitelné
   soubory pro DU1.  Pøi zmìnì kteréhokoli souboru musí pøelo¾it jen zmìnìný
   soubor a závislosti. Pokud bude Makefile vypadat jako skript, odeètou se 3b.


</XMP>

Testovací obrázek: <A HREF="du1-obrazek.ppm">du1-obrazek.ppm</A>

<HR>
<HR>
<XMP>


C) Obecné pokyny pro vypracování domácích úkolù (rev 21.2.2024)

*  Pro úkoly v jazyce C pou¾ívejte ISO C11 (soubory *.c)
   Pou¾ití nepøenositelných konstrukcí není dovoleno.

*  Úkoly zkontrolujte pøekladaèem napøíklad takto:
      gcc -g -std=c11 -pedantic -Wall -Wextra priklad1.c
   místo gcc mù¾ete pou¾ít i jiný pøekladaè.
   V  souvislosti s tím napi¹te do poznámky na zaèátku
   souboru jméno pøekladaèe, kterým byl program testován
   (implicitní je verze GNU C instalovaná na serveru merlin).

   POZOR: Zkontrolujte pamì»ové operace speciálním parametrem pøekladu.
   (Makefile: CFLAGS += -fsanitize=address, LDFLAGS += -fsanitize=address).

*  Programy  pi¹te, pokud je to mo¾né, do jednoho zdrojového
   souboru. Dodr¾ujte pøedepsaná jména souborù.

*  Na zaèátek ka¾dého souboru napi¹te poznámku, která bude
   obsahovat jméno, fakultu, oznaèení pøíkladu a datum.

   Pøíklad:
   // primes.c
   // Øe¹ení IJC-DU1, pøíklad a), 20.3.2111
   // Autor: Kapitán Nemo, FIT
   // Pøelo¾eno: gcc 10.2
   // ...popis pøíkladu - poznámky, omezení, atd

* Úkoly je nutné zabalit programem zip takto:
       zip xnemok99.zip *.c *.h Makefile

  Jméno xnemok99 nahradíte vlastním. ZIP neobsahuje adresáøe.
  Ka¾dý si zkontroluje obsah ZIP archivu jeho rozbalením v prázdném adresáøi
  a napsáním "make run".

* Øe¹ení se odevzdává elektronicky v ISVUT (velikost souboru je omezena)

* Odvezdávejte pouze nezbytnì nutné soubory -- ne *.EXE !

* Úkoly neodevzdané v termínu budou za 0 bodù.

* Opsané úkoly budou hodnoceny 0 bodù pro v¹echny zùèastnìné
  a to bez výjimky (+bonus v podobì náv¹tìvy u disciplinární komise).


</XMP>
<HR>
<ADDRESS>
Poslední modifikace: <!-- begin flastmod -->
19. February 2024<!-- end -->
<BR>
Pokud naleznete na této stránce chybu, oznamte to dopisem na adresu
peringer AT fit.vutbr.cz
</ADDRESS>

</body>
</html>


